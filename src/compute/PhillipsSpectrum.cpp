#include "PhillipsSpectrum.h"

namespace Ocean
{
    double generateCoefficient(const Utils::Vector2& k)
    {
        // L is the largest wave that can be generated by the wind
        double L = Settings::windSpeed * Settings::windSpeed / Settings::gravity;
        double L2 = L * L;

        // To eliminate waves going perpendicular to the wind direction
        double kDotW = Utils::dot(k, Settings::windDirection);
        double kDotW2 = kDotW * kDotW;

        double k2 = Utils::lengthSquared(k);
        double k4 = k2 * k2;

        // A is a constant
        double A = 0.0001;

        // To eliminate waves with very small length
        if (k2 < 0.000001) return 0.0;

        /*
        * The result is the Phillips spectrum value for the given wave vector k.
        * The formula is:
        *   A * exp(-1 / (k * L)^2) * (k . w) / k^4
        * where:
        *   A = 0.0001
        *   L = windSpeed^2 / gravity
        *   k = wave vector
        *   w = wind direction
        */
        double result = A / k4 * std::exp(-1.0 / (k2 * L2)) * kDotW2;

        // If the wave is going opposite to the wind direction, reduce its
        if (kDotW < 0.0) result *= 0.01;

        // Supress waves with very small length
        double l = L / 1000.0;
        double l2 = l * l;

        /*
        * The result is multiplied by an exponential factor to supress waves
        * with very small length.
        * The formula is:
        *   exp(-k^2 * l^2)
        * where:
        *   k = wave vector
        *   l = L / 1000
        */
        double mulFactor = std::exp(-k2 * l2);

        // The result is the Phillips spectrum value for the given wave vector k
        return result * mulFactor;
    }

    void generateSpectrum()
    {
        int N = Settings::SCREEN_WIDTH;
        int M = Settings::SCREEN_HEIGHT;
        for (int i = -M/2; i < M/2; i++)
        {
            for (int j = -N/2; j < N/2; j++)
            {
                double kx = (2.0 * M_PI * j) / Settings::Lx;
                double ky = (2.0 * M_PI * i) / Settings::Ly;

                Utils::Vector2 k(kx, ky);

                double phk = std::sqrt(generateCoefficient(k) / 2.0);

                int index = (i + M/2) * N + (j + N/2);

                double er = Utils::GaussianNumber();
                double ei = Utils::GaussianNumber();

                spectrumFreq[index] = Utils::Complex(phk * er, phk * ei);
            }
        }
    }

    void updateHeights(double t)
    {
        int N = Settings::SCREEN_WIDTH;
        int M = Settings::SCREEN_HEIGHT;

        for (int i = 0; i < N * M; i++)
            spectrumReel[i] = spectrumFreq[i];

        Ocean::IFFT(spectrumReel, M);

        for (int i = 0; i < M; i++)
        {
            for (int j = 0; j < N; j++)
            {
                int index = i * N + j;
                double h = spectrumReel[index].getReal();
                heights[index] = h;
            }
        }
    }

} // namespace Ocean